# 문제풀이: 2156 포도주 시식

## 문제 이해하기

먼저 문제를 정확히 이해해봅시다:

- 포도주 잔들이 일렬로 놓여 있어요
- 선택한 잔은 반드시 다 마셔야 해요
- **중요한 규칙**: 연속으로 3잔을 모두 마실 수는 없어요
- 목표: 가장 많은 양의 포도주를 마시기

예시를 보면: [6, 10, 13, 9, 8, 1]
- 1번째(6) + 2번째(10) + 4번째(9) + 5번째(8) = 33이 최대입니다

## 힌트 1: 작은 예제로 시작하기

포도주가 1개, 2개, 3개일 때를 생각해봅시다.

- 잔이 1개일 때: 당연히 그 잔을 마시면 됩니다
- 잔이 2개일 때: 둘 다 마셔도 연속 3잔이 아니므로 괜찮아요
- 잔이 3개일 때: 3개를 모두 마실 수는 없어요! 최대 2개만 골라야 합니다

## 힌트 2: 연속 3잔 규칙 이해하기

"연속 3잔을 못 마신다"는 규칙을 다시 생각해보면:
- OOX (1,2번 마시고 3번 안 마심) → 가능
- OXO (1,3번 마시고 2번 안 마심) → 가능  
- XOO (2,3번 마시고 1번 안 마심) → 가능
- OOO (1,2,3번 모두 마심) → **불가능!**

즉, 3개 연속된 잔 중에서는 최소 1개는 건너뛰어야 해요.

## 힌트 3: 현재 잔을 기준으로 경우의 수 나누기

i번째 잔에서 할 수 있는 선택을 생각해봅시다:

1. **i번째 잔을 안 마시는 경우**: i-1번째까지의 최대값 그대로
2. **i번째 잔을 마시는 경우**: 
   - i-1번째를 안 마셨다면: i-2번째까지의 최대값 + i번째 잔
   - i-1번째를 마셨다면: i-3번째까지의 최대값 + i-1번째 잔 + i번째 잔

## 힌트 4: 동적 계획법(DP) 접근

DP[i]를 "i번째 잔까지 고려했을 때 마실 수 있는 포도주의 최대 양"이라고 정의해봅시다.

각 위치에서 가능한 경우들:
- 현재 잔을 안 마시기
- 현재 잔만 마시기 (이전 잔은 안 마심)
- 현재 잔과 이전 잔을 연속으로 마시기 (그 전 잔은 안 마심)

## 힌트 5: 점화식 세우기

i번째 위치에서의 최대값은 다음 세 가지 중 최대값입니다:

1. `DP[i-1]` (i번째 잔을 안 마시는 경우)
2. `DP[i-2] + wine[i]` (i번째 잔만 마시는 경우)
3. `DP[i-3] + wine[i-1] + wine[i]` (i-1번째와 i번째를 연속으로 마시는 경우)

## 힌트 6: 초기 조건 설정하기

DP 배열의 초기값을 설정해야 합니다:
- DP[1] = 첫 번째 잔의 양
- DP[2] = 첫 번째 + 두 번째 잔의 양 (둘 다 마셔도 됨)
- DP[3]부터는 점화식을 적용

## 힌트 7: 예제로 확인하기

[6, 10, 13, 9, 8, 1] 예제로 직접 계산해보세요:
- DP[1] = 6
- DP[2] = 6 + 10 = 16
- DP[3] = max(16, 6+13, 0+10+13) = 23
- 이런 식으로 계속...

## 힌트 8: 구현 방향

1. DP 배열을 선언하고 초기값 설정
2. 3번째 잔부터 마지막 잔까지 반복하면서
3. 각 위치에서 세 가지 경우 중 최대값을 선택
4. 마지막 DP[n] 값이 정답

주의: 배열 인덱스 범위를 벗어나지 않도록 조심하세요!