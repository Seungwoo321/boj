# 문제풀이: 2225 합분해

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구한다.

## 알고리즘 분류

- 수학
- 다이나믹 프로그래밍

## 아이디어

이 문제는 DP로 해결할 수 있는 경우의 수 문제다.

상태 정의

- dp[n][k]: n을 만들기 위해 k개의 수를 사용하는 경우의 수
- n은 만들어야 하는 합이고, k는 사용한 수의 개수

점화식 고민:

n을 만들기 위해 마지막에 i를 더한 경우 dp[n-i][k-1]는 n-i를 k-1개의 수로 만드는 경우의 수다.
n-i에 i를 더해서 n을 만들면 k개의 숫자를 사용하게 된다.

그래서 처음에는 이렇게 생각했다.

- dp[n][k] = dp[n-i][k-1] + 1

다시 생각해보면 구하는 건 경우의 수이므로 n-i를 만드는 경우의 수는 n-i개니까 모두 더해야 된다.
따라서 최종 점화식은 이렇게 되어야 할 것이다.

- dp[n][k] = sum(dp[n-i]k-1) (i는 0부터 n까지)

초기값:

dp[0][0] = 1 (아무 것도 선택하지 않는 경우)

아무것도 선택하지 않는 경우가 1인건 왜 일까?

- 아무것도 하지 않아서 (k=0) 합이 0이 되는 (n=0) 경우의 수를 의미
- "공집합"이나 "아무것도 하지 않는 경우"를 의미
- 조합론에서 이런 경우를 1로 초기화하는 것이 일반적

예시로 이해하기

- 만약 dp[0][0] = 0 이라면?

k=1일 때 0을 만드는 경우의 수는 0 하나를 사용해서 0을 만들 수 있으므로 1이 되어야한다.
그런데 초기값이 0이 되면 점화식에 따라서 0이라는 잘못된 계산이 발생한다.
이게 연쇄적으로 잘못된 결과가 나올수 있기때문에 수학적 일관성을 위해 1로 초기화 해야된다.

풀이:

3중 반복문이 필요하다.

- 1부터 k까지의 반복 k
- 0부터 N까지의 반복 n
- 0부터 n까지의 반복 i

dp[n-i][k-1]는 n-i의 숫자를 만드는데 k-1개의 숫자를 사용한 경우의 수다.
n-i에 i를 더하면 n을 만들기 위해 k개의 숫자를 사용한게 되고 n-i개를 만들 수 있는 경우의 수를 다 더해야 된다.

헷갈린 부분:

k 반복문은 가장 안쪽에 있으면 안된다. k=x 일때 k=x-1에 대한 모든 i값이 계산되어 있어야 하기 때문이다.
k는 작은 값부터 순차적으로 계산되어야 하며 각 k값에 대해 모든 n과 i의 계산이 완료되어야 한다.
