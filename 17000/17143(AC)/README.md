# 문제풀이

낚시왕은 1열부터 가장 가까운 상어를 낚고 매초마다 오른쪽으로 이동한다. 상어도 매초마다 움직인다. 낚시왕이 오른쪽 끝까지 이동하면서 낚은 상어의 총 무게를 구한다.

## 입력

- 첫 째줄 r, c, m
  - r : 열 (맵의 세로 길이)
  - c : 행 (맵의 가로 길이)
  - m : 상어 정보의 갯수
- m 개의 줄의 상어의 정보 y, x, s, d, z 가 주어진다
  - y : 상어의 위치 좌표 열
  - x : 상어의 위치 좌표 행
  - s : 상어의 초당 이동거리
  - d : 상어의 이동 방향 (1-위, 2-아래, 3-왼쪽, 4-오른쪽)
  - z : 상어의 무게

## 로직

1. 쉬운 문제 풀이를 위해서 상어의 배열의 각 y, x, d를 -1 한다.
2. 상어 배열을 무게가 큰 상어부터 내림차순 정렬한다.
3. 상어를 격자판에 그리면서 중복되면 큰 상어가 잡아먹고 먹힌 상어는 따로 표시하는 함수를 구현 (catchShark)
4. 낚시왕이 상어를 낚아서 격자판에서 삭제하고 무게를 누적해서 반환하는 함수를 구현 (fishShark)
5. 상어가 매초마다 이동 하는 로직을 구현. 동시에 이동 하므로 격자판에서 일단 삭제하고 상어의 배열정보를 업데이트 한다. (moveShark)

## 맞왜틀

- 상어의 배열 정보를 수정 할 때 조건을 잘 못줘서 처음부터 잘못된 입력값으로 시작함
- moveShark에서 상어가 이동하다가 벽에 부딪혀서 반대로 돌때
  - 몇번이고 부딪혀서 방향전환 될 수 있기 때문에 반복문이 필요함
  - 몇번이고 부딪혀서 방향전환 될 수 있기 d (이동방향)값도 업데이트 필요함
- 상어를 이동할 때 격자판을 . 으로 초기화 시키고 catchShark 에서 다시 격자판에 기록하는 것만으로는 같은 좌표에 있는 상어에 대한 처리 로직이 완벽하지 않아서 처음에 무게가 큰 상어 부터 이동 할 수 있도록 내림 차순 정렬 하는 로직을 추가함
  - catchShark 함수의 로직이 이미 위치한 상어가 이동한 상어보다 크면 이동한 상어를 잡아먹고 이동 할 위치가 비어있거나 이동한 상어가 더 크면 이동한 상어를 격자판에 놓는다. 무게가 큰 상어부터 이동하는 내림차순 정렬 로직을 추가한 이후로는 항상 무게가 큰 상어 부터 이동하기 때문에 새로 이동한 상어가 위치한곳에 상어가 있다면 항상 잡아먹힌다.

## 리팩토링 및 강의 답안과 비교

- moveShark 에서 `s %= d < 2 ? 2 * (row - 1) : 2 * (col - 1);` 코드 제거
  - 강의의 답안에서는 처음입력값을 받은데서 수행하는 이동 후 제자리에 오는 횟수를 나머지 연산자로 계산해서 빼는 로직을 moveShark 함수안에서 계산하니까 약 816 ~ 828ms 시간이 걸리고 이 로직은 제외하고 반복문만 남기니까 약 448ms 시간으로 개선되고 메모리 사용량도 감소했다.
- 강의의 답안에서는 상어의 동시 이동과 상어의 포식을 구현하기 위해서 새로운 임시 격자판 배열(tmp)을 생성해서 기존 상어와 새 상어의 무게를 비교해서 살아 남은 상어를 기록하고 기존 격자판을 임시 격자판 배열로 교체한다.
- 방향을 1,2,3,4가 아닌 0,1,2,3으로 하면 방향전환시 XOR연산자로 쉽게 구현 할 수 있어서 답안과 동일하게 구현했다.
  - 0 <-> 1 : 00 ^ 01 = 01, 01 ^ 01 = 00
  - 2 <-> 3 : 10 ^ 01 = 11, 11 ^ 01 = 10
